\documentclass{article}

\usepackage[a4paper, margin=1in]{geometry}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{float}
\usepackage[utf8]{inputenc}
\usepackage[brazil]{babel}

\graphicspath{ {./images/} }
\captionsetup{font=small}

\title{Informação Profissional em Ciência da Computação:\\
       Arquitetura de Computadores}
\author{Carlos Eduardo Gallo Filho \\
        Caio Uehara Martins\\
        Pedro Henrique Mendes de Lima}

\date{\today}

\begin{document}

\maketitle

\section{Introdução}
\subsection{Arquitetura e Organização}
Os termos arquitetura e organização de computadores servem para descrever a
estrutura e funções de computadores e a forma como ele é projetado. Um sistema
de computador, como qualquer sistema, consiste em um conjunto inter-relacionado
de componentes. O sistema é mais bem caracterizado em termos de estrutura (a
forma como os componentes são interligados) e função (a operação dos
componentes individuais).

Antes de nos aprofundarmos nos mesmos vamos diferenciá-los melhor. Arquitetura
de computador refere-se aos atributos de um sistema visíveis a um programador
ou, em outras palavras, aqueles atributos que possuem um impacto direto sobre a
execução logica de um programa. Organização de computador refere-se as unidades
operacionais e suas interconexões que percebam as especificações de
arquitetura. 

Por exemplo, é uma questão de projeto de arquitetura se um processador terá uma
instrução de multiplicação ou não, enquanto é uma questão de organização se essa
instrução será implementada por uma unidade de multiplicação especial ou por um
mecanismo que faça uso repetido da unidade de adição do sistema. A decisão
organizacional pode ser baseada na previsão da frequência de uso da instrução
de multiplicação, na velocidade relativa das duas técnicas e no custo e tamanho
físico de uma unidade de multiplicação especial.

Historicamente, e ainda hoje, a distinção entre arquitetura e organização tem
sido importante. Muitos fabricantes de computador oferecem uma família de
modelos de computador, todos com a mesma arquitetura, mas com diferenças na
organização. Consequentemente, os diferentes modelos na família tem diferentes
características de preço e desempenho. Além do mais, uma arquitetura em
particular pode se espalhar por muitos anos e abranger diversos modelos
diferentes de computador, com sua organização variando conforme a mudança da
tecnologia.

Em uma classe de computadores chamada microcomputadores, o relacionamento entre
arquitetura e organização e muito próximo. As mudanças na tecnologia não apenas
influenciam a organização, mas também resultam na introdução de arquiteturas
mais poderosas e mais complexas. Geralmente, há menor requisito para
compatibilidade de geração a geração para essas máquinas menores.

\subsection{Estruturas e Funções}
Um sistema hierárquico é um conjunto de subsistemas inter-relacionados, cada
qual responsável por implementar uma função necessária à camada superior,
formando um sistema final dividido em camadas de abstrações. A natureza
hierárquica dos sistemas complexos é essencial para seu projeto e sua
descrição. O projetista só precisa lidar com um nível particular do sistema de
cada vez. O comportamento em cada nível depende somente de uma
caracterização simplificada e resumida do sistema do próximo nível mais baixo.
Em cada nível, o projetista está interessado em sua estrutura e função:

\begin{itemize}
    \item \textbf{Estrutura:} O modo como os componentes são inter-relacionados.
    \item \textbf{Função:} A operação individual de cada componente como parte
        da estrutura.
\end{itemize}

\subsubsection{Função}
Em geral, existem apenas quatro funções básicas que um computador pode exercer,
das quais:

\begin{itemize}
    \item \textbf{Processamento de dados:} Os dados podem ter uma grande
        variedade de formas, e a amplitude de exigências de processamento é
        grande. Contudo, existem poucos métodos fundamentais ou tipos de
        processamento de dados.
    \item \textbf{Armazenamento de dados:} Mesmo que o computador esteja
        processando dados na hora (isto é, os dados e são processados, e os
        resultados saem de imediato), o computador deve temporariamente
        armazenar pelo menos as peças de dados que estão sendo trabalhadas em
        um dado momento. Assim, há ao menos uma função de armazenamento de
        dados de curto prazo. Igualmente importante, o computador apresenta uma
        função de armazenamento de dados de longo prazo. Arquivos de dados são
        armazenados no computador para recuperação e atualização.
    \item \textbf{Movimentação de dados:} O ambiente operacional do computador
        consiste em dispositivos que servem como fontes ou destinos de dados.
        Quando dados são recebidos de ou entregues a um dispositivo que é
        diretamente conectado ao computador, o processo é conhecido como
        entrada-saída (E/S ou, do inglês, \textit{input-output} -- I/O), e o
        dispositivo é referido como um periférico. Quando os dados são
        movimentados por longas distancias, a ou de um dispositivo remoto, o
        processo e conhecido como comunicações de dados.
    \item \textbf{Controle:} Dentro de um computador, uma unidade de controle
        gerencia os recursos do computador e orquestra o desempenho de suas
        partes funcionais na resposta às instruções.
\end{itemize}

\subsubsection{Estrutura de um computador}
A estrutura de um computador de um único processador pode ser denotada pelos
quatro principais componentes estruturais:
\begin{itemize}
    \item \textbf{Unidade central de processamento (CPU — do inglês, Central
        Processing Unit):} Controla a operação de um computador e realiza suas
        funções e processamento de dados.
    \item \textbf{Memória principal:} Armazena dados.
    \item \textbf{E/S:} Move dados entre o computador e seu ambiente externo.
    \item \textbf{Sistema de interconexão:} Algum mecanismo que proporciona
        comunicação entre CPU, memoria principal e E/S.
\end{itemize}

Podendo haver um ou mais de cada um dos componentes supracitados. Contudo, o
mais complexo é o processador (CPU) que pode ser descrito por:

\begin{itemize}
    \item \textbf{Unidade de controle:} Controla a operação da CPU e, portanto,
        do computador.
    \item \textbf{Unidade Lógica e Aritmética (ULA):} Executa operações
        lógicas e aritméticas.
    \item \textbf{Registradores:} Proporciona o armazenamento interno da CPU.
    \item \textbf{Interconexão da CPU:} Alguns mecanismos que proporcionam
        comunicação entre a unidade de controle, ULA e registradores.
\end{itemize}

Outra característica proeminente de computadores contemporâneos é o uso de
múltiplas camadas de memória, chamada de memória cache, entre o processador e a
memória principal. Dizendo de forma simples, observamos que a memória cache é
menor e mais rápida que a memória principal e é usada para deixar mais rápido o
acesso da memória, ao colocar os dados na cache, a partir da memória principal,
que provavelmente poderão ser usados em um futuro próximo. Um maior
aprimoramento do desempenho pode ser obtido pelo uso de múltiplos níveis de
cache, com o nível 1 (L1), mais próximo do core, e os níveis adicionais (L2, L3
e daí por diante), progressivamente mais longe do core. Nesse esquema, o nível
n e menor e mais rápido que o nível n + 1.

Descendo a um nível mais profundo, examinamos a estrutura interna de um único
core de um processador exemplar da arquitetura \textit{Z/Architecture}:

\begin{itemize}
    \item \textbf{ISU (unidade de sequência de instrução — do inglês,
        Instrucional Sequence Unit):} Determina a sequência na qual as
        instruções são executadas em uma arquitetura superescalar.

    \item \textbf{IFU (unidade de busca de instrução — do inglês, Instruction
        Fetch Unit):} Lógica para buscar instruções.

    \item \textbf{IDU (unidade de decodificação de instrução — do inglês,
        Instruction Decode Unit):} A IDU e alimentada por buffers IFU e é
        responsável por analisar e decodificar todos os opcodes da
        \textit{z/Architecture}.

    \item  \textbf{LSU (unidade de load/store — do inglês, Load-Store Unit):} A
        LSU contém uma cache de dados 96 kB L1 e gerencia o trafego de dados
        entre a cache de dados L2 e as unidades de execução funcionais. É
        responsável por lidar com todos os tipos de acessos de operandos de
        todas as extensões, modos e formatos, como definido na
        \textit{z/Architecture}.

    \item \textbf{XU (unidade de tradução — do inglês, Translation Unit):} A XU
        traduz os endereços lógicos a partir de instruções nos endereços físicos
        na memória principal. Além de também conter o TLB (Translation Lookaside
        Buffer),usado para incrementar o acesso da memória.

    \item \textbf{FXU (unidade de ponto fixo — do inglês, Fixed Point Unit):} A
        FXU executa as operações aritméticas de ponto fixo.

    \item \textbf{BFU (unidade de ponto flutuante binário — do inglês, Binary
        Floating-point Unit):} A BFU lida com todas as operações de ponto
        flutuante binário e hexadecimal, bem como com operações de multiplicação
        de ponto fixo.

    \item \textbf{DFU (unidade de ponto flutuante decimal — do inglês, Decimal
        Floating-point Unit):} A DFU lida tanto com as operações de ponto fixo
        como com as de ponto flutuante sobre os números que são armazenados como
        dígitos decimais.

    \item \textbf{RU (unidade de recuperação — do inglês, Recovery Unit):} A RU
        mantém a cópia do estado completo do sistema que inclui todos os
        registradores, coleta sinais de falha de hardware e gerencia as ações de
        recuperação do hardware.

    \item \textbf{COP (coprocessador dedicado — do inglês, Dedicated
        Co-Processor):} O COP é responsável pela compressão de dados e funções
        de criptografia para cada core.

    \item \textbf{I-cache:} esta e uma cache de instrução 64 kB L1 que permite
        que a IFU pré busque instruções antes que sejam necessárias.

    \item \textbf{Controle L2:} Esta é a lógica de controle que gerencia o
        tráfego através de duas caches L2.

    \item \textbf{Dados-L2:} Trata-se de uma cache de dados de 1 MB L2 para todo o
        trafego de memória diferente das instruções.

    \item \textbf{Instr-L2:} É uma cache de instrução 1 MB L2.
\end{itemize}

A maioria dos componentes do computadores são interligados em uma placa-mãe, que
é uma placa de circuito impresso (PCB -- do inglês, Printed Circuit Board). A
placa é composta por camadas, geralmente de duas a dez, que interconectam os
componentes por trilhas de cobre que são gravados na placa. A placa também
oferece suporte a hardwares externos através de placas de expansões.

Os elementos mais proeminentes que constituem a placa-mãe são os chips. Um chip é um pedaço
único de material semicondutor, em geral de silício, no qual os circuitos
eletrônicos e portas logicas são fabricados. O produto resultante é referido
como um circuito integrado (CI). A placa-mãe contém um slot ou um soquete para o chip
do processador. Ha também slots para os chips da memória,
chips de controlador E/S e outros componentes chave do computador. Para
computadores desktop, os slots de expansão permitem a inclusão de mais
componentes na placa de expansão. Assim, uma placa-mãe moderna conecta somente
poucos componentes individuais, com cada chip contendo de alguns milhares até
centenas de milhões de transistores.

Outros componentes da placa mãe são:

\begin{itemize}
    \item Slots do PCI-express para adaptador de vídeo de alta
       performance e para periféricos adicionais.

    \item Controladores Ethernet e portas Ethernet para conexões de rede.
        
    \item Soquetes USB para dispositivos periféricos.

    \item Soquetes ATA Serial (SATA) para conexão com a memória de disco.

    \item Interfaces para chips de memória principal DDR (do inglês, Double
        Data Rate).

    \item Chipset(sul e norte):  O nome se refere a um conjunto de circuitos
        integrados que são responsáveis por fazer com que todos os componentes
        do computador, desde o disco rígido até o processador, possam trocar
        informações e assim realizar as tarefas que exigimos deles.
\end{itemize}

\section{Evolução histórica}
\subsection{Primeira geração: Arquitetura de Von Neumann}
A primeira geração de computadores é conhecida pelo uso das válvulas para
representar os elementos lógicos digitais e a memória. E também, o
\textbf{conceito de programa armazenado}, atribuída ao matemático John Von
Neumann, que surgiu para a construção do computador EDVAC (Eletronic Discrete
Variable Computer), mas foi principalmente discutido no desenvolvimento do
computador IAS, o qual é um protótipo para quase todos os computadores de
propósito geral de hoje em dia.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.65\textwidth]{ias.png}
    \caption{Estrutura do IAS.}
\end{figure}

Para se explicar a estrutura do IAS, deve-se atentar a 5 partes principais:

\begin{enumerate}
    \item Um computador terá de ser capaz de executar as operações elementares
        básicas (adição, subtração, multiplicação, divisão). Normalmente, para
        essas funções são criadas unidades específicas para tais, comportadas em
        uma unidade maior centralizadora denominada CA ou unidade lógica e
        aritmética.

    \item Um computador terá de ser capaz de dar sequenciamento adequado as suas
        operações, instruções e as instruções de controle (comandos que regem o
        próprio sequenciamento do computador). Á essas unidades é denominada uma
        unidade central chamada CC ou controle central.

        As partes 1) e 2) juntas são chamadas de C. 

    \item Um computador terá a necessidade de processar sequências longas de
        operações, que, geralmente, não conseguem ser efetuadas em uma única
        leva de comandos. Logo, requer-se uma unidade que armazene dados por
        períodos duráveis para resolver problemas mais complexos, como cálculos.

        Essa unidade é denominada M ou memória.

        Analogamente ao funcionamento do corpo humano, essas três partes podem
        ser comparadas a parte cognitiva do corpo. Ou seja, a unidade lógica e
        aritmética, o controle central e a memória são o conjunto pensante do
        computador. Mas, assim como o corpo humano, se faz necessário a
        comunicação com o mundo externo, tal é feito por um canal denominado
        meio de gravação de saída do dispositivo ou R, de modo que as últimas
        duas partes interagem com esse canal para satisfazer a necessidade de
        interação com o externo. 

    \item A parte de entrada do meio R, a qual deve transferir as informações
        desse para dentro de M e C é chamada de entrada ou I. É de boa prática a
        entrada passar os dados para dentro de M e nunca diretamente para C. 

    \item Similarmente, a parte de saída do meio R, a qual deve transferir as
        informações de M e C para o meio R, é chamada de saída ou O. É de boa
        prática, também, a saída passar de M para R, assim, nunca diretamente
        por C. 
\end{enumerate}

Assim, resumidamente, temos a memória principal, que armazena dados e
instruções; a unidade lógica e aritmética (ALU), que opera os binários; a
unidade de controle, que interpreta e executa instruções e, por fim, o
equipamento de saída (E/S), que conecta o meio interno ao meio externo do
computador.

Como já antes dito, o modelo de IAS reflete em grande parte dos computadores
atuais, por isso sua importância no mundo da computação.

\subsubsection{Endereçamento de memória}
O IAS possui 4.096 locais de armazenamento chamados de palavras, sendo esses
dados ou instruções, cada um com 40 bits. As palavras são dividas em duas:
palavra de número e palavra de instrução.

\begin{itemize}
        \item Palavra de número: contém um bit de sinal e outros 39 de
            armazenamento para o número. 
        \item Palavra de instrução: pode conter duas instruções de 20 bits,
            cada uma contendo um opcode de 8 bits - referência que um
            processador possui para uma determinada instrução - e 12 bits de
            endereço de memória.
\end{itemize}

\begin{figure}[H]
   \centering
   \includegraphics[width=0.75\textwidth]{palavras.png}
   \caption{Tipos de palavras de memória.}
\end{figure}

\subsubsection{Registradores}
Passando para as unidades menores do computador IAS, tem-se os locais de
armazenamento da unidade de controle e da ALU, chamados de registradores.

\begin{itemize}
    \item \textbf{Registrador de buffer de memória (MBR):} é o local onde permanece
        a palavra a ser armazenada na memória ou enviada à unidade E/S,
        como também é o local para receber a palavra a partir da E/S ou a
        partir da memória.
    \item \textbf{Registrador de endereço de memória (MAR):} local que contém o
        endereço da memória da palavra a ser escrito ou lido pelo MBR.
    \item \textbf{Registrador de instruções (IR):} contém o opcode de 8 bits da
        instrução que está sendo executada.
    \item \textbf{Registrador de buffer de instrução (IBR):} mantém temporariamente
        a instrução da direita da palavra da memória.
    \item \textbf{Contador do programa (PC):} mantém o próximo par de instruções a
        ser buscado na memória.
    \item \textbf{Acumulador (AC) e quociente-multiplicador (MQ):} registradores
        usados para realizar as operações da ALU, sendo o AC o que mantém
        os bits mais significativos e o MQ os bits menos significativos.
\end{itemize}

\subsubsection{Ciclos do IAS}
\subsubsection{Conjunto de instruções IAS}
\subsection{Segunda geração: Transístores}
\subsection{Terceira geração: Circuitos Integrados}
\subsection{Gerações posteriores}
\subsection{Comparação entre as gerações}

\section{Aplicações} 
As subseções a seguir trazem algumas aplicações da arquitetura de computadores.
\subsection{Paradigmas de arquitetura}

\subsubsection{CISC}
O paradigma de arquitetura CISC (\textit{Complex Instruction Set Computer})
denotam uma escolha de projeto na qual o conjunto das instruções utilizadas são
projetadas para a execução de um conjunto de operações de baixo nível,
envolvendo por exemplo, operações aritméticas juntas de uma escrita na memória,
tudo em uma mesma instrução.

Uma notória vantagem do uso do paradigma CISC se dá por facilitar a construção
de compiladores e a programação em baixo nível, pois as instruções fornecem um
pequeno nível de abstração. Além disso, por implementar as instruções a comuns
nível de \textit{hardware}, o consumo de memória, tempo de execução e tamanho dos
programas costumam ser menores. Uma desvantagem direta ao paradigma é o fato do
projeto do hardware se tornar muito mais trabalhoso e complexo, além de
necessitar maior quantidade de componentes, e por consequência, aumento de
calor.

\subsection{RISC}
Em contrapartida ao CISC, existe o paradigma RISC (\textit{Reduced Instruction
Set Computer}). Um projeto RISC tem como princípio implementar um pequeno número
mínimo de instruções simples, que em sua maioria são executadas em apenas um
ciclo de máquina.

Como esperado, processadores RISCs são mais fáceis de serem implementados e
produzidos, gastando menor quantidade de componentes e melhorando a eficiência
térmica, além de facilitar a implementação do \textit{pipelining} a nível do
código de máquina. Como desvantagem, sua programação de baixo nível é mais
complexa, bem como a construção de compiladores, o que implica uma má
implementação a nível de software ser mais danosa.

\subsection{Arquitetura x86} 
A arquitetura de processadores x86 foi concebida pela intel e é o exemplar mais
popular do tipo CISC, trazendo muitos princípios de \textit{design} que só
existiam até então em \textit{mainframes}. A arquitetura teve seu surgimento
junto ao processador 8086 em 1978, que foi introduzido como uma extensão de 16
bits ao famoso 8080, primeiro microprocessador de propósito geral.

A linhagem de processadores x86 continuou a evoluir, levando ao aparecimento do
80286, 80386 e 80486, cada qual incrementando novas instruções na arquitetura,
além de melhorar aspectos de organização utilizando a rápida evolução da
microeletrônica. O 80286 possibilitou a ampliação do número de memória
endereçável para 16 MB, ao invés de 1 MB que seu antecessor era capaz. Já o
80386 foi o primeiro processador de 32 bits, trazendo muitas melhorias em
comparação ao 80236, o que inclui o suporte a multitarefas. Sucessivamente, o
80486 incrementou uma nova tecnologia de cache junto de uma avançada
\textit{pipelining} de instruções, além de também adicionar um coprocessador
para instruções matemáticas complexas.

Já entrando na quinta geração de processadores, surge o Pentium, que sucede o
80486 adicionando tecnologia superescalar, que é uma forma de paralelismo a
nível de instrução utilizando múltiplas unidades de execução. Seguindo para o
Pentium Pro, este continuou a implementação de técnicas multi-escalares,
incluindo análise do fluxo de dados, execução especulativa, entre outras.

Com os desktops se tornando cada vez mais comuns e novas necessidades surgindo,
levando ao aparecimento de instruções orientadas ao processamento de multimídia.

O Pentium II surge incorporando a tecnologia MMX da Intel no Pentium Pro. Em
seguida, o Pentium III trouxe muitas outras novas instruções de ponto flutuante,
que melhoravam muito a performance em algumas aplicações específicas. O ultimo
processador da linha foi o Pentium 4, que apenas melhorou algumas tecnologias
utilizadas em seu antecessor.

Após a virada do século, o desenvolvimento de novos processadores acabou mudando
de rumo, quando foi alcançado limites práticos para o aumento do \textit{clock},
por exemplo. Como não era possível mais aproveitar os avanços da miniaturização
para melhorar a performance, os processadores passaram a serem multiplicados em
diferentes núcleos. O primeiro \textit{dual core} x86 foi o Intel Core.
Posteriormente o Intel Core foi estendido a 64 bits, surgindo posteriormente
variantes como o Core 2 Quad, com quatro nucelos. Outra tecnologia importante
adicionada à linha Core 2 foram as AVE, que possuíam instruções de grande
tamanho para processamento eficiente de vetores.

Por mais que a arquitetura x86 seja antiga, ela se mostrou em constante
evolução, o que inclui sempre a adição de novos recursos e instruções,
aproveitando os avanços da microeletrônica para mudanças na organização. Ainda
assim, processadores recentes possuem retrocompatibilidade com programas
antigos, devido ao fato da arquitetura ter evoluído sem alterar instruções já
existentes, o que colaborou para a manutenção da popularidade da arquitetura.

\subsection{Sistemas embarcados}
Sistemas embarcados são caracterizados pela combinação de \textit{hardware} e
\textit{software} utilizados em conjunto para formar um sistema de propósito
específico, em contraste aos computadores de propósito geral abordados. Os tipos
de sistemas embarcados são dos mais variados, incluindo desde sistemas
automotivos até telefones celulares.

A organização de um sistema embarcado, como esperado, também difere à de um
sistema de propósito geral, o que inclui partes estritamente planejadas para o
ambiente de trabalho do sistema. Isso implica que no geral, sistemas embarcados
diferem muito entre si, e portanto são difíceis de serem caracterizados de
maneira genérica. No entanto, algumas características comuns de sistemas
embarcados podem ser descritas:

\begin{figure}[h]
    \centering
    \includegraphics[width=0.4\textwidth]{embarcado.png}
    \caption{Possível organização de um sistema embarcado}
\end{figure}

\begin{itemize}
    \item Possuem uma interface de comunicação com o ambiente,
        o que inclui sensores integrados.

    \item A interface de usuário é simplificada, sendo até mesmo
        inexistente em alguns projetos.

    \item A interface de depuração muitas vezes é utilizada para
        diagnostico do sistema controlado, não apenas do microcontrolador.

    \item Uso de hardware especializado, incluindo até mesmo circuitos
        não digitais em alguns casos.

    \item Software possui uma função e objetivo fixo e bem definido.

    \item Eficiência é de extrema importância, o que inclui performance,
        baixo consumo de energia, espaço e consumo de memória.
\end{itemize}

Alguns sistemas embarcados complexos acabam incorporando processadores de
aplicação, capaz de executarem sistemas operacionais complexos, o que inclui a
adição da natureza de propósito geral aos microcontroladores, ainda que em suma
maioria estes possuam apenas um processador dedicado.

\subsubsection{Microcontroladores}
Enquanto microprocessadores se beneficiaram dos avanços da miniaturização de
componentes aumentando seu conjunto de instruções, memória e núcleos, os
microcontroladores o usam para integrar todos os outros componentes de um
computador em um único chip, o que inclui memória RAM, ROM, \textit{clock} e
unidade de controle de entrada e saída. Obviamente, os elementos de um
microcontrolador são mais simples, porém possuem alta eficiência energética e
baixíssimo custo.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.6\textwidth]{uc.png}
    \caption{Organização típica de um microcontrolador}
\end{figure}

\subsubsection{Internet das Coisas (IoT)}
O termo IoT (\textit{Internet of Things}) é utilizado para denotar o fenômeno de
expansão da rede de comunicação entre dispositivos embarcados "inteligentes". O
fenômeno vem se tornando cada vez mais popular e denota a inclusão de sistemas
micro-controlados em objetos dos mais variados tipos, como geladeira, lampadas e
torradeiras. a IoT é responsável pela integração dos possíveis objetos para
formar um grande sistema automatizáveis. Um exemplo clássico de IoT são os
sistemas de automação residencial.

Uma caraterística importante dos sistemas IoT é o caráter da conexão dos seus
principais dispositivos, definida por baixa largura de banda, baixa repetição de
captura e uso de dados.

\subsection{Arquitetura ARM} 
A família de arquitetura ARM é caracterizada por uma grande gama de
microprocessadores e microcontroladores, sendo a exemplar mais popular do tipo
RISC. Diferente da arquitetura x86, a empresa por trás da arquitetura ARM não
fabrica processadores, mas sim os projeta, além de projetar também a arquitetura
em si, vendendo licenças de fabricação às fabricantes.

Como consequência do paradigma RISC, os chips ARM possuem tamanho reduzido e
baixíssimo consumo energético, principalmente pela pequena quantidade de
componentes necessários. Essas características levam os microprocessadores ARM a
dominarem o mercado de dispositivos móveis, como o de \textit{smartphones}.

O conjunto de instruções ARM é desenvolvido para eficiente implementação e
execução. Todas instruções são de 32 bits e seguem formato regular, permitindo
sua implementação em uma vasta gama de produtos. Além disso, ainda existe o
conjunto de instruções \textit{Thumb}, que é um subconjunto do conjunto de
instruções ARM tradicionais, cujas instruções são implementadas em 16 bits para
melhor performance e menor largura de barramento de memória, permitindo
consequentemente melhor densidade de código.

Talvez uma das principais famílias de microprocessadores ARM sejam os da linha
Cortex, que são nomeados de acordo com suas respectivas aplicações. O Cortex-A
e o Cortex-A50 são processadores de aplicação, ou seja, são capazes de rodar sistemas
operacionais completos, sendo utilizados em smartphones, por exemplo. Já o
Cortex-R é projetado para aplicações embarcadas de baixa latência, contendo
otimizações tanto em seu conjunto de instrução quanto sua organização para
melhor desempenho. Por ultimo, existe a série Cortex-M, que é desenvolvida
princialmente para o domínio de microcontroladores.

O ARM Cortex-M3 por exemplo, que é utilizado para microcontroladores de 16 e 32
bits, contando com funcionalidades de \textit{debug} e \textit{trace}. Uma
diferença relatável do Cortex-M3 é que ele utiliza barramentos diferentes para
instruções e dados, que difere do IAS, por exemplo, e que torna possível ler
ambos barramentos ao mesmo tempo, oferecendo paralelismo. Além disso, possui um
decodificador \textit{Thumb}, uma avançada ULA (Unidade Lógica e Aritmética)
com suporte à multiplicação e divisão, controle logico e interface com os outros
componentes do processador.

Além do "núcleo" do processador, o Cortex-M3 também possui alguns componentes,
dos quais:

\begin{itemize}
    \item \textbf{NVIC:} Provê gerenciamento de interrupções e controle
        energético.
    \item \textbf{ETM:} Componente de depuração que permite reconstrução da
        execução de programas
    \item \textbf{Debug access port (DAP):} Interface para depuração externa
    \item \textbf{Debug logic:} Fornece funcionalidades básicas de depuração.
    \item \textbf{ICode interface:} Pega as instruções do espaço de memória de
        código
    \item \textbf{SRAM \& peripheral interface:} Interface de leitura e escrita
        de memória e dispositivos externos.
    \item \textbf{Bus matrix:} Conecta o núcleo e a interface de depuração com
        o barramento externo do microcontrolador.
    \item \textbf{Memory protection unit:} Responsável pela proteção de dados
        críticos do sistema operacional. 
\end{itemize}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{cortex.png}
    \caption{Típica estrutura de um chip de um microcontrolador baseado no
    Cortex-M3.}
\end{figure}

Já um microcontrolador baseado no Cortex-M3, possui:

\begin{itemize}
    \item \textbf{Core and memory:} Região que inclui o processador, RAM
        estática, memória \textit{flash} e interface de depuração.
    \item \textbf{Parallel I/O ports:} Portas paralelas de I/O configuráveis.
    \item \textbf{Serial interfaces:} Suporte para I/O serial.
    \item \textbf{Analog interfaces:} Conversores A/D e D/A para suporte a
        sensores e atuadores.
    \item \textbf{Timers and triggers:} Responsável por acompanhar eventos de
        contagem e manipulação de tempo, além de gerar formas de ondas e
        gatilhar ações temporais em periféricos.
    \item \textbf{Clock management:} Controla os osciladores e relógios do chip.
    \item \textbf{Energy management:} Gerencia os modos de operação em baixa
        energia.
    \item \textbf{Security:} Implementação do padrão AES \textit{Advanced
        Encryption Standard}.
    \item \textbf{32-bit bus:} Barramento que conecta todos os componentes do
        chip.
    \item \textbf{Peripheral bus:} Barramento que permite interconexão dos
        módulos sem envolver o processador.
\end{itemize}

\subsection{Computação em Nuvem}
Com o avanço das tecnologias de telecomunicações, o que envolve as redes de
computadores, se tornou comum o oferecimento de serviços computacionais
disponíveis pela Internet \textbf{sob demanda}. Tais serviços incluem
armazenamento de arquivos, hospedagem de aplicações, máquinas virtuais, execução
de softwares entre outros. Isso resulta em uma menor complexidade na manutenção
e maior escalabilidade dos sistemas finais.

A justificativa para a existência dos serviços em nuvem é a redução do trabalho
necessário para provisionamento e manutenção de uma infraestrutura de TI para
atividades que envolvem produtos finais pertencentes às camadas mais superiores
da stack de software\footnote{O termo stack de software é utilizado para denotar
os diferentes subsistemas de software que compõe uma plataforma completa.}, pois
esse passa a ser terceirizado a um provedor de nuvem (CSP, do inglês
\textit{Cloud Service Provider}). Os serviços nuvem oferecem portanto uma menor
complexidade para seus usuários, bem como maior escalabilidade.

As modalidades de serviços podem ser divididas em ordem crescente de abstração
em: IaaS (\textit{Infrastructure as a Service}), PaaS (\textit{Plataform as a
Service}) e SaaS (\textit{Software as a Service}). O primeiro se refere ao
fornecimento de uma infraestrutura de hardware virtual, provendo um ambiente
customizável a nível de sistema operacional. Já o segundo, provê um ambiente
para hospedagem de aplicações arbitrárias do usuário, contando com todo o resto
administrado pelo provedor do serviço. Por fim, o Saas se refere ao serviço da
execução de um programa na infraestrutura da provedora.

Ademais as aparentes vantagens, a arquitetura em nuvem apresenta muitos
problemas críticos, como de segurança e privacidade. Atualmente se existe o
oligopólio das \textit{big techs}, cujos serviços principais são pautados na
manipulação, processamento e posse dos dados de seus clientes e usuários. Além
disso, a arquitetura nuvem possui menor flexibilidade quanto ao controle e
conhecimento do usuário sobre as camadas inferiores do sistema.

\nocite{stallings}

\bibliographystyle{plain}
\bibliography{ref}

\end{document}
